---
echo: false
warning: false
editor_options: 
  chunk_output_type: console
---

```{r}
# Librerias 
library(readxl)
library(tidyverse)
library(nortest)
library(dplyr)
library(ggplot2)
library(GGally) # para la funcion ggpairs
library(gt)
library(gtExtras)
library(moments)
library(leaps)
library(MASS)
library(lmtest)
library(car)
library(BSDA) # Test del signo
library(glmnet)
library(glmtoolbox)
library(MASS)
library(rsample)
library(lawstat)
library(caret) # Para particion train test
```

```{r}
datos <- read_excel("Datos/Corregida - COMPILADO DATOS COMUNIDAD DE CUIDADO Y CENTRO DÍA.xlsx", 
                      range = "B2:AN561", col_types = c("date", 
                      "skip", "text", "text", "text", "skip", 
                      "text", "numeric", "text", "skip", 
                      "skip", "skip", "skip", "numeric", 
                      "skip", "skip", "skip", "skip", "numeric", 
                      "skip", "skip", "skip", "skip", "numeric", 
                      "skip", "skip", "skip", "skip", "numeric", 
                      "skip", "skip", "skip", "skip", "numeric", 
                      "skip", "skip", "skip", "skip", "numeric"))
colnames(datos) <- c("Fecha", "Localidad", "Programa", "Unidad_atencion", 
                     "Sexo", "Edad", "Etnia", "Peso", "Talla",
                     "LRT_CM","LRT_A", "LRM_90","LRM_R")
datos$Sexo <- as.factor(datos$Sexo)
datos$Etnia <- as.factor(datos$Etnia)
datos <- datos[-which(datos$Edad<60),] # >60
datos <- datos |> filter(!(abs(LRT_A-LRT_CM) > 3 | abs(LRM_90-LRM_R) > 3))
datos <- datos |> as.data.frame()
```



```{r}
#| results: hide
# Crear índices estratificados basados en la variable 'Sexo'
set.seed(123)
indices <- createDataPartition(datos$Sexo, p = 0.8, list = FALSE)

# Dividir los datos
train <- datos[indices, ]   # 80% entrenamiento
test <- datos[-indices, ]   # 20% validación

# Verificar proporciones en cada conjunto
prop.table(table(datos$Sexo))  # Proporciones en el dataset completo
prop.table(table(train$Sexo))  # Proporciones en entrenamiento
prop.table(table(test$Sexo))   # Proporciones en validación
```

```{r}
datos_copia <- datos
datos <- train
```

# Modelos

En esta sección se ajustarán tres tipos de modelos —Normal, LASSO y Gamma— para estimar la talla de adultos mayores en Colombia, utilizando diferentes mediciones: LRT_A, LRT_CM, LRM_R y LRM_90.

La elección de estos modelos se basa en la revisión de la literatura, que indica que las tallas suelen seguir una distribución normal. Además, se incluyen los modelos LASSO y Gamma debido a la naturaleza de la variable respuesta (talla), que es siempre positiva, lo que los hace adecuados para este tipo de datos.

## Modelo Normal

### LRT Antropómetro

Se hace una búsqueda del mejor modelo normal por cada número de posibles combinaciones de variables de las cuales se tenga evidencia que influyen en la talla de adultos mayores (Edad, Sexo, Etnia y LRT_A). Primero se hará la búsqueda usando todo el conjunto de datos.

```{r}
#| results: hide
regfit.full <- regsubsets(Talla ~ LRT_A + Edad + Sexo + Etnia,
                          datos, nbest = 1, nvmax = 10) # Mejor modelo de cada número de variables 

(reg.summary <- summary(regfit.full))
```

A continuación, se muestra el BIC para cada mejor modelo del correspondiente tamaño:

```{r}
reg.summary$bic
```

Usando el criterio del BIC, el mejor modelo es el de 3 variables:

```{r}
which.min(reg.summary$bic)
plot(reg.summary$bic , xlab = "Number of Variables",
ylab = "BIC", type = "l")
points(3, reg.summary$bic[3], col = "red", cex = 2,
pch = 20)
plot(regfit.full , scale = "bic")
```

Los coeficientes del mejor modelo usando el criterio de BIC son:

```{r}
coef(regfit.full, 3)
```

Esto sugiere usar el modelo $Talla = 58.84 + 2.17 \cdot LRT\_A - 0.11 \cdot Edad + 3.22 \cdot Sexo$,\
$$Sexo = \begin{cases} 1 & \text{si sexo = masculino} \\ 0 & \text{si sexo = femenino} \end{cases}$$

Ahora se usará ***K - fold cross validation*** con el fin de calcular directamente los errores de predicción sobre los datos de testeo y evitar así el sobreajuste.

-   Se crean ***K - folds*** (pliegues) de aproximadamente igual tamaño. En este caso fijamos $k = 10$. Como tenemos $543$ datos, cada pliegue será de tamaño 54 o 55.
-   El $k-ésimo$ pliegue servirá para testear, y los demás pliegues se juntan para entrenar los modelos. Osea que se usará un $90\%$ de los datos para entrenamiento y $10\%$ para test.
-   Para $k = 1,\cdots,10,$ se calcula el MSE.
-   Luego, se promedia el MSE a través de los $10$ pliegues y se obtiene el MSE promedio.

```{r}
# Crear 5 folds
set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- lm(Talla ~ LRT_A + Edad + Sexo, data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data)

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

El MSE para el modelo de 3 variables ($LRT\_A, Edad, Sexo$) es:

```{r}
# Para ir almacenando los MSE de los modelos y las longitudes
MSEs <- data.frame(Modelo = character(),
                   Medida = character(),
                   MSE = numeric(),
                   MSE_validacion = numeric())

# Promedio del error cuadrático medio
mean(errores)

modelo_fin <- lm(Talla ~ LRT_A + Edad + Sexo, data = datos)
predicciones_test <- predict(modelo_fin, newdata = test)
# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Normal", Medida = "LRT_A", MSE = mean(errores), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
modelo_comp <- lm(Talla ~ LRT_A + Edad + Sexo, data = datos_copia)
datos_copia$Normal_LRT_A <- modelo_comp$fitted.values
```

### LRT cinta métrica

Se hace una búsqueda del mejor modelo normal por cada número de posibles combinaciones de variables de las cuales se tenga evidencia que influyen en la talla de adultos mayores (Edad, Sexo, Etnia y LRT_CM). Primero se hará la búsqueda usando todo el conjunto de datos.


```{r}
#| results: hide
regfit.full <- regsubsets(Talla ~ LRT_CM + Edad + Sexo + Etnia,
                          datos, nbest = 1, nvmax = 10) # Mejor modelo de cada número de variables 

(reg.summary <- summary(regfit.full))
# names(reg.summary)
```

A continuación, se muestra el BIC para cada mejor modelo del correspondiente tamaño:

```{r}
reg.summary$bic
```

Usando el criterio BIC, el mejor modelo es el de 3 variables:

```{r}
which.min(reg.summary$bic)
plot(reg.summary$bic , xlab = "Number of Variables",
ylab = "BIC", type = "l")
points(3, reg.summary$bic[3], col = "red", cex = 2,
pch = 20)
plot(regfit.full , scale = "bic")
```

Los coeficientes del mejor modelo usando el criterio de BIC son:

```{r}
coef(regfit.full, 3)
```

Esto sugiere usar el modelo $Talla = 56.78 + 2.14 \cdot LRT\_CM - 0.11 \cdot Edad + 4.30 \cdot Sexo$,\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$

Ahora usamos nuevamente ***K - fold cross validation*** con el fin de calcular directamente los errores de predicción sobre los datos de testeo y evitar así el sobreajuste de la misma manera que se realizó para el modelo normal de $LRT_A$. 

```{r}
# Crear 10 folds
set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- lm(Talla ~ LRT_CM + Edad + Sexo, data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data)

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

El MSE para el modelo de 3 variables ($LRT\_CM, Edad, Sexo$) es:

```{r}
# Promedio del error cuadrático medio
mean(errores)


modelo_fin <- lm(Talla ~ LRT_CM + Edad + Sexo, data = datos)
predicciones_test <- predict(modelo_fin, newdata = test)
# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Normal", Medida = "LRT_CM", MSE = mean(errores), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
modelo_comp <- lm(Talla ~ LRT_CM + Edad + Sexo, data = datos_copia)
datos_copia$Normal_LRT_CM <- modelo_comp$fitted.values
```

### LRM pierna estirada

Se hace una búsqueda del mejor modelo normal por cada número de posibles combinaciones de variables de las cuales se tenga evidencia que influyen en la talla de adultos mayores (Edad, Sexo, Etnia y LRM_R). Primero se hará la búsqueda usando todo el conjunto de datos.

```{r}
#| results: hide
regfit.full <- regsubsets(Talla ~ LRM_R + Edad + Sexo + Etnia,
                          datos, nbest = 1, nvmax = 10) # Mejor modelo de cada número de variables 

(reg.summary <- summary(regfit.full))
```

A continuación, se muestra el BIC para cada mejor modelo del correspondiente tamaño:

```{r}
reg.summary$bic
```

Usando el criterio BIC, el mejor modelo es el de 3 variables:

```{r}
which.min(reg.summary$bic)
plot(reg.summary$bic , xlab = "Number of Variables",
ylab = "BIC", type = "l")
points(3, reg.summary$bic[3], col = "red", cex = 2,
pch = 20)
plot(regfit.full , scale = "bic")
```

Los coeficientes del mejor modelo usando el criterio de BIC son:

```{r}
coef(regfit.full, 3)
```

Esto sugiere usar el modelo $Talla = 67.21 + 2.22 \cdot LRM\_R - 0.10 \cdot Edad + 3.75 \cdot Sexo$,\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$

Nuevamente, se hará la búsqueda del mejor modelo usando ***K - fold cross validation*** con el fin de calcular directamente los errores de predicción sobre los datos de testeo y evitar así el sobreajuste.

```{r}
# Crear 10 folds
set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- lm(Talla ~ LRM_R + Edad + Sexo, data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data)

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

El MSE para el modelo de 3 variables ($LRM\_R, Edad, Sexo$) es:

```{r}
# Promedio del error cuadrático medio
mean(errores)


modelo_fin <- lm(Talla ~ LRM_R + Edad + Sexo, data = datos)
predicciones_test <- predict(modelo_fin, newdata = test)
# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)


 MSEs <- rbind(MSEs, data.frame(Modelo = "Normal", Medida = "LRM_R", MSE = mean(errores), MSE_validacion = MSE_test)) # No se incluye pq aparentemente hay una leve homocedasticidad en los errores
```

### LRM pierna a 90°

Se hace una búsqueda del mejor modelo normal por cada número de posibles combinaciones de variables de las cuales se tenga evidencia que influyen en la talla de adultos mayores (Edad, Sexo, Etnia y LRM_90). Primero se hará la búsqueda usando todo el conjunto de datos.

```{r}
#| results: hide
regfit.full <- regsubsets(Talla ~ LRM_90 + Edad + Sexo + Etnia,
                          datos, nbest = 1, nvmax = 10) # Mejor modelo de cada número de variables 

(reg.summary <- summary(regfit.full))
# names(reg.summary)
```

A continuación, se muestra el BIC para cada mejor modelo del correspondiente tamaño:

```{r}
reg.summary$bic
```

Usando el criterio BIC, el mejor modelo es el de 3 variables:

```{r}
which.min(reg.summary$bic)
plot(reg.summary$bic , xlab = "Number of Variables",
ylab = "BIC", type = "l")
points(3, reg.summary$bic[3], col = "red", cex = 2,
pch = 20)
plot(regfit.full , scale = "bic")
```

Los coeficientes del mejor modelo usando el criterio de BIC son:

```{r}
coef(regfit.full, 3)
```

Esto sugiere usar el modelo $Talla = 65.90 + 2.19 \cdot LRM\_90 - 0.10 \cdot Edad + 4.91 \cdot Sexo$,\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$

Ahora se hará la búsqueda del mejor modelo usando ***K - fold cross validation*** con el fin de calcular directamente los errores de predicción sobre los datos de testeo y evitar así el sobreajuste.


```{r}
# Crear 10 folds
set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- lm(Talla ~ LRM_90 + Edad + Sexo, data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data)

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

El MSE para el modelo de 3 variables ($LRM\_90, Edad, Sexo$) es:

```{r}
# Promedio del error cuadrático medio
mean(errores)


modelo_fin <- lm(Talla ~ LRM_90 + Edad + Sexo, data = datos)
predicciones_test <- predict(modelo_fin, newdata = test)
# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)


MSEs <- rbind(MSEs, data.frame(Modelo = "Normal", Medida = "LRM_90", MSE = mean(errores), MSE_validacion = MSE_test)) # No se incluye pq el modelo no está bien especificado
```

### Resúmen modelos Normal

En general, los modelos ajustados incluyeron como variables la edad, el sexo y el intercepto, variando únicamente entre las mediciones utilizadas: LRT_A, LRT_CM, LRM_90 y LRM_R. Cada modelo produjo diferentes estimaciones para los parámetros, lo que resulta en ecuaciones distintas para estimar la talla de los adultos mayores.

El criterio principal para seleccionar el mejor modelo, ya sea normal o de otro tipo, será **el menor error cuadrático medio (MSE)**. Esto se debe a que un MSE más bajo indica que el modelo realiza estimaciones de la talla más cercanas a los valores reales, reflejando una mayor precisión.

La tabla de los errores cuadráticos medios para la regresión lineal simple es la siguiente: 

```{r}
MSEs[1:4,]
```

El modelo con menor error cuadrático medio es el que tiene en cuenta la medida LRT con antropómetro: 

$$Talla = 58.84 + 2.17 \cdot LRT\_A - 0.11 \cdot Edad + 3.22 \cdot Sexo$$

A continuación, se procederá a validar los supuestos del mejor modelo identificado. Esta validación es crucial, ya que si los supuestos no se cumplen, el modelo no puede considerarse válido y sus resultados podrían no ser confiables.

```{r}
reg <- lm(Talla ~ LRT_A + Edad + Sexo, data = datos)
(summary.reg <- summary(reg))
```

El modelo tiene un $R^2$ ajustado de $0.8856$, es decir que aproximadamente un $88.56\%$ de la variabilidad de la talla es explicada por LRT_A, la edad y el sexo. 

***Linealidad:*** Con el fin de verificar que la relación entre la talla y las variables LRT_A (discriminando por sexo) y la edad es lineal, se visualiza el gráfico de los residuos vs los valores predichos del modelo $\left(\hat{e},\hat{y} \right)$:

```{r}
plot(reg, which = 1)
```

El gráfico no muestra ningún patrón marcado, la ubicación de los puntos parece ser aleatoria alrededor de cero, indicando también homoscedasticidad en los residuales y posible independencia de los mismos. El gráfico muestra algunos valores atípicos que valdría la pena explorar.

***Independencia de los errores:*** Aunque nuestros datos no son temporales, el test de Durbin-Watson nos puede ayudar a evaluar la autocorrelación de los errores del modelo:

```{r}
dwtest(reg)
```

La estadística del test de Durbin-Watson es muy cercano a $2$, se concluye que los errores son independientes.

***Normalidad de los errores:*** Se realiza el gráfico QQ-plot para comparar la distribución de los residuales del modelo con la distribución teórica de una normal. También se hace el test de normalidad de Lilliefors y Anderson-Darling:

```{r}
plot(reg, which = 2)
lillie.test(reg$residuals)
ad.test(reg$residuals)
```

El QQ-plot muestra que los residuales se ajustan aceptablemente a una distribución normal. Las pruebas de normalidad de Lilliefors y Anderson-Darling también apoyan este resultado.

***Homoscedasticidad:*** Aunque no se vio un patron que indicara heteroscedasticidad en el gráfico de los residuales vs los valores predichos, a continuación se muestra el gráfico de los residuales estandarizados vs los valores predichos con el fin de mejorar la interpretabilidad de la homoscedasticidad y tener una visión más clara de las observaciones atípicas e influyentes:

```{r}
plot(reg, which = 3)
```

No se observan patrones que indiquen hereroscedasticidad en los residuos (forma de cono o embudo). Se siguien observando algunas observaciones atípicas y/o influyentes.

Adicional, se realiza la prueba de Breusch-Pagan para verificar la homoscedasticidad de los residuales:

```{r}
bptest(reg)
```

No se rechaza la hipótesis nula de que los errores del modelo son homoscedasticos.

***Multicolinealidad:*** Se verifica que las variables incluídas en el modelo no están altamente correlacionadas entre sí, y así evitar obtener resultados inestables que dificulten la interpretabilidad de los coeficientes del modelo. Se calculan los Factores de Inflación de la Varianza (VIFs):

```{r}
vif(reg)
```

Dado que los VIFs son mucho menores a 5, esto indica que cada variable tiene una correlación moderada (leve) con las demás. Por lo que se puede concluir que los resultados del modelo posiblemente no estarán muy afectados por la multicolinealidad.

***El modelo está bien especificado:*** Se hace el test de RESET para examinar si el modelo ajustado está bien especificado o si se han omitido términos no lineales o interacciones importantes:

```{r}
resettest(reg, type="regressor")
resettest(reg, type="fitted")
```

No se rechaza la hipótesis nula de que el modelo está bien especificado.

***Observaciones atípicas y de alto apalancamiento:*** 

```{r}
#| layout-ncol: 2
plot(reg,which=5)
stud_res<-studres(reg)
# head(sort(abs(stud_res),decreasing=TRUE))
boxplot(stud_res)
```

Usando los residuales estudentizados, se observan $5$ datos atípicos.

```{r}
#| layout-ncol: 2
n <- nrow(datos)
corte <- 4/(n-length(reg$coefficients)-2) #Es una regla usada en la práctica
plot(reg, which=4, cook.levels=corte)
abline(h=corte, lty=2, col="red")
cooksd<-cooks.distance(reg)
# cooksd[which(cooksd>corte)]

influencePlot(reg, id.method="identify", main="Gráfico de influencia", sub="El tamaño del círculo es proporcional a la D_Cook")
```

En total 29 observaciones superan el umbral especificado para la distancia de Cook, pero esto no significa que todas sean influyentes (alto leverage). Particularmente hay 3 observaciones que son marcadas como influyentes significativamente según la distancia de Cook. Esto indica que la inclusión de estas observaciones en el modelo pueden tener una influencia significativa en los coeficientes del modelo y en la predicción de la talla. Se debe explorar con cautela estas observaciones y decidir qué hacer con ellas.

Para esto, se puede comprobar el cambio en los coeficientes del modelo al excluir estas observaciones influyentes.

```{r}
reg2 <- update(reg,subset={setdiff(row(datos)[,1], c(533,43,549))})
summary(reg2)
```

Las estimaciones de los coeficientes del modelo sin las obervaciones influyentes han cambiado un poco respecto al modelo original. El $R^2$ ajustado ha incrementado un poco también.

## Modelo Lasso

### LRT Antropómetro

Para ajustar el modelo LASSO, se consideran todas las variables que podrían influir en la estimación de la talla: Edad, Sexo, Etnia y LRT_A. El modelo se encargará automáticamente de seleccionar las variables más significativas. 

Se utiliza el método de ***k-fold cross validation*** con $k = 10$ usando los mismos
folds utilizados en el modelo normal para que las métricas sean comparables. El objetivo principal de la validación cruzada en el modelo LASSO es obtener el valor de $\lambda$ 
que minimice el error cuadrático medio cruzado a través de los 10 folds. Es decir, se busca el valor de $\lambda$ que minimice el MSE a través de los 10 folds (lo mismo que en el modelo normal).

```{r}
datos2 <- datos %>% # dataframe auxiliar para obener los id de los k-folds
  mutate(index = row_number())

# Se crean los k-fols igual que en el modelo normal
set.seed(123)
folds <- vfold_cv(datos2, v = 10)

fold_id <- rep(0, nrow(datos2)) # id's de los k-folds
for(i in 1:10){
  prueba = assessment(folds$splits[[i]])
  ids = prueba %>% pull(index)
  filas = datos2 %>% filter(index %in% ids)
  fold_id[filas$index] = i
}
```

El modelo LASSO ajusta los coeficientes de las variables, llevando a cero aquellos que no son significativos. Además, determina de forma óptima el parámetro lambda que controla la penalización y selección de variables.
  
```{r}
# Matriz diseño y variable respuesta
x <- model.matrix(Talla ~ LRT_A + Edad + Sexo + Etnia, data = datos)[,-1]
y <- datos$Talla
```

Se ajusta el modelo en cada fold usando `cv.glmnet`:

```{r}
grid <- 10^seq(3, -3, length.out = 500) # grilla de valores lambda
# alpha = 1 se refiere a LASSO
cv.out <- cv.glmnet(x, y, alpha = 1, lambda = grid, foldid = fold_id, type.measure = "mse")

plot(cv.out) # muestra dónde se miniza la función de pérdida
```

```{r}
# Para calcular MSE test
# Matriz de diseño para el conjunto de test
x_test <- model.matrix(Talla ~ LRT_A + Edad + Sexo + Etnia, data = test)[,-1]
y_test <- test$Talla

# Obtener el mejor lambda (el que minimiza el MSE en validación cruzada)
best_lambda <- cv.out$lambda.min

# Ajustar el modelo con el mejor lambda usando todos los datos de entrenamiento
modelo_lasso <- glmnet(x, y, alpha = 1, lambda = best_lambda)

# Hacer predicciones en test
predicciones_test <- predict(modelo_lasso, newx = x_test)

# Calcular el MSE en test
MSE_test <- mean((y_test - predicciones_test)^2)


MSEs <- rbind(MSEs, data.frame(Modelo = "LASSO", Medida = "LRT_A", MSE = min(cv.out$cvm), MSE_validacion = MSE_test))
```

El valor de $\lambda$ óptimo y el MSE del modelo ajustado con ese valor de $\lambda$ son respectivamente:

```{r}
paste("Valor de lambda óptimo:", round(cv.out$lambda.min,3)) # Mejor lambda
paste("MSE:", round(min(cv.out$cvm),3)) # Este es el MSE promedio de los 10 folds
```


Los coeficientes resultantes del modelo ajustado son:
  
```{r}
coef(cv.out, s = "lambda.min")
```

Finalmente, la ecuación propuesta por este modelo para estimar la talla en adultos mayores es:

$$Talla = 58.49 + 2.16 \cdot LRT\_A - 0.09 \cdot Edad + 3.07 \cdot Sexo + 0.87 \cdot Ind$$
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$

$$Ind = \begin{cases} 1 & \text{si Etnia = Indígena} \\ 0 & \text{en otro caso} \end{cases}$$

### LRT cinta métrica

Para ajustar el modelo LASSO, se consideran todas las variables que podrían influir en la estimación de la talla: Edad, Sexo, Etnia y LRT_CM. El modelo se encargará automáticamente de seleccionar las variables más significativas. 

Se utiliza el método de ***k-fold cross validation*** con $k = 10$ usando los mismos
folds utilizados en el modelo normal para que las métricas sean comparables. El objetivo principal de la validación cruzada en el modelo LASSO es obtener el valor de $\lambda$ 
que minimice el error cuadrático medio cruzado a través de los 10 folds. Es decir, se busca el valor de $\lambda$ que minimice el MSE a través de los 10 folds (lo mismo que en el modelo normal).

El modelo LASSO ajusta los coeficientes de las variables, llevando a cero aquellos que no son significativos. Además, determina de forma óptima el parámetro lambda que controla la penalización y selección de variables.
  
```{r}
# Matriz diseño y variable respuesta
x <- model.matrix(Talla ~ LRT_CM + Edad + Sexo + Etnia, data = datos)[,-1]
y <- datos$Talla
```

Se ajusta el modelo en cada fold usando `cv.glmnet`:

```{r}
grid <- 10^seq(3, -3, length.out = 500) # grilla de valores lambda
# alpha = 1 se refiere a LASSO
cv.out <- cv.glmnet(x, y, alpha = 1, lambda = grid, foldid = fold_id, type.measure = "mse")

plot(cv.out) # muestra dónde se miniza la función de pérdida
```

```{r}
# Para calcular MSE test
# Matriz de diseño para el conjunto de test
x_test <- model.matrix(Talla ~ LRT_CM + Edad + Sexo + Etnia, data = test)[,-1]
y_test <- test$Talla

# Obtener el mejor lambda (el que minimiza el MSE en validación cruzada)
best_lambda <- cv.out$lambda.min

# Ajustar el modelo con el mejor lambda usando todos los datos de entrenamiento
modelo_lasso <- glmnet(x, y, alpha = 1, lambda = best_lambda)

# Hacer predicciones en test
predicciones_test <- predict(modelo_lasso, newx = x_test)

# Calcular el MSE en test
MSE_test <- mean((y_test - predicciones_test)^2)


MSEs <- rbind(MSEs, data.frame(Modelo = "LASSO", Medida = "LRT_CM", MSE = min(cv.out$cvm), MSE_validacion = MSE_test))
```

El valor de $\lambda$ óptimo y el MSE del modelo ajustado con ese valor de $\lambda$ son respectivamente:

```{r}
paste("Valor de lambda óptimo:", round(cv.out$lambda.min,3)) # Mejor lambda
paste("MSE:", round(min(cv.out$cvm),3)) # Este es el MSE promedio de los 10 folds
```

Los coeficientes resultantes del modelo ajustado son:
  
```{r}
coef(cv.out, s = "lambda.min")
```

Finalmente, la ecuación propuesta por este modelo para estimar la talla en adultos mayores es:

$$Talla = 55.04 + 2.15 \cdot LRT\_CM - 0.11 \cdot Edad + 4.30 \cdot Sexo + 1.79 \cdot BM + 3.18 \cdot Ind + 0.93 \cdot Rrom$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\
$$BM = \begin{cases} 1 & \text{si Etnia = Blanco-Mestizo} \\ 0 & \text{en otro caso} \end{cases}$$
$$Ind = \begin{cases} 1 & \text{si Etnia = Indígena} \\ 0 & \text{en otro caso} \end{cases}$$
$$Rrom = \begin{cases} 1 & \text{si Etnia = Rrom} \\ 0 & \text{en otro caso} \end{cases}$$

### LRM pierna estirada

Para ajustar el modelo LASSO, se consideran todas las variables que podrían influir en la estimación de la talla: Edad, Sexo, Etnia y LRM_R. El modelo se encargará automáticamente de seleccionar las variables más significativas. 

Se utiliza el método de ***k-fold cross validation*** con $k = 10$ usando los mismos
folds utilizados en el modelo normal para que las métricas sean comparables. El objetivo principal de la validación cruzada en el modelo LASSO es obtener el valor de $\lambda$ 
que minimice el error cuadrático medio cruzado a través de los 10 folds. Es decir, se busca el valor de $\lambda$ que minimice el MSE a través de los 10 folds (lo mismo que en el modelo normal).

El modelo LASSO ajusta los coeficientes de las variables, llevando a cero aquellos que no son significativos. Además, determina de forma óptima el parámetro lambda que controla la penalización y selección de variables.
  
```{r}
# Matriz diseño y variable respuesta
x <- model.matrix(Talla ~ LRM_R + Edad + Sexo + Etnia, data = datos)[,-1]
y <- datos$Talla
```

Se ajusta el modelo en cada fold usando `cv.glmnet`:

```{r}
grid <- 10^seq(3, -3, length.out = 500) # grilla de valores lambda
# alpha = 1 se refiere a LASSO
cv.out <- cv.glmnet(x, y, alpha = 1, lambda = grid, foldid = fold_id, type.measure = "mse")

plot(cv.out) # muestra dónde se miniza la función de pérdida
```

```{r}
# Para calcular MSE test
# Matriz de diseño para el conjunto de test
x_test <- model.matrix(Talla ~ LRM_R + Edad + Sexo + Etnia, data = test)[,-1]
y_test <- test$Talla

# Obtener el mejor lambda (el que minimiza el MSE en validación cruzada)
best_lambda <- cv.out$lambda.min

# Ajustar el modelo con el mejor lambda usando todos los datos de entrenamiento
modelo_lasso <- glmnet(x, y, alpha = 1, lambda = best_lambda)

# Hacer predicciones en test
predicciones_test <- predict(modelo_lasso, newx = x_test)

# Calcular el MSE en test
MSE_test <- mean((y_test - predicciones_test)^2)


MSEs <- rbind(MSEs, data.frame(Modelo = "LASSO", Medida = "LRM_R", MSE = min(cv.out$cvm), MSE_validacion = MSE_test))
```

El valor de $\lambda$ óptimo y el MSE del modelo ajustado con ese valor de $\lambda$ son respectivamente:

```{r}
paste("Valor de lambda óptimo:", round(cv.out$lambda.min,3)) # Mejor lambda
paste("MSE:", round(min(cv.out$cvm),3)) # Este es el MSE promedio de los 10 folds
```

Los coeficientes resultantes del modelo ajustado son:
  
```{r}
coef(cv.out, s = "lambda.min")
```

Finalmente, la ecuación propuesta por este modelo para estimar la talla en adultos mayores es:

$$Talla = 64.53 + 2.22 \cdot LRM\_R - 0.10 \cdot Edad + 3.75 \cdot Sexo + 2.86 \cdot BM + 4.72 \cdot Ind + 5.75 \cdot Rrom$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\
$$BM = \begin{cases} 1 & \text{si Etnia = Blanco-Mestizo} \\ 0 & \text{en otro caso} \end{cases}$$\
$$Ind = \begin{cases} 1 & \text{si Etnia = Indigena} \\ 0 & \text{en otro caso} \end{cases}$$\
$$Rrom = \begin{cases} 1 & \text{si Etnia = Rrom} \\ 0 & \text{en otro caso} \end{cases}$$

### LRM pierna a 90°

Para ajustar el modelo LASSO, se consideran todas las variables que podrían influir en la estimación de la talla: Edad, Sexo, Etnia y LRM_90. El modelo se encargará automáticamente de seleccionar las variables más significativas. 

Se utiliza el método de ***k-fold cross validation*** con $k = 10$ usando los mismos
folds utilizados en el modelo normal para que las métricas sean comparables. El objetivo principal de la validación cruzada en el modelo LASSO es obtener el valor de $\lambda$ 
que minimice el error cuadrático medio cruzado a través de los 10 folds. Es decir, se busca el valor de $\lambda$ que minimice el MSE a través de los 10 folds (lo mismo que en el modelo normal).

El modelo LASSO ajusta los coeficientes de las variables, llevando a cero aquellos que no son significativos. Además, determina de forma óptima el parámetro lambda que controla la penalización y selección de variables.
  
```{r}
# Matriz diseño y variable respuesta
x <- model.matrix(Talla ~ LRM_90 + Edad + Sexo + Etnia, data = datos)[,-1]
y <- datos$Talla
```

Se ajusta el modelo en cada fold usando `cv.glmnet`:

```{r}
grid <- 10^seq(3, -3, length.out = 500) # grilla de valores lambda
# alpha = 1 se refiere a LASSO
cv.out <- cv.glmnet(x, y, alpha = 1, lambda = grid, foldid = fold_id, type.measure = "mse")

plot(cv.out) # muestra dónde se miniza la función de pérdida
```


```{r}
# Para calcular MSE test
# Matriz de diseño para el conjunto de test
x_test <- model.matrix(Talla ~ LRM_90 + Edad + Sexo + Etnia, data = test)[,-1]
y_test <- test$Talla

# Obtener el mejor lambda (el que minimiza el MSE en validación cruzada)
best_lambda <- cv.out$lambda.min

# Ajustar el modelo con el mejor lambda usando todos los datos de entrenamiento
modelo_lasso <- glmnet(x, y, alpha = 1, lambda = best_lambda)

# Hacer predicciones en test
predicciones_test <- predict(modelo_lasso, newx = x_test)

# Calcular el MSE en test
MSE_test <- mean((y_test - predicciones_test)^2)


MSEs <- rbind(MSEs, data.frame(Modelo = "LASSO", Medida = "LRM_90", MSE = min(cv.out$cvm), MSE_validacion = MSE_test))
```

El valor de $\lambda$ óptimo y el MSE del modelo ajustado con ese valor de $\lambda$ son respectivamente:

```{r}
paste("Valor de lambda óptimo:", round(cv.out$lambda.min,3)) # Mejor lambda
paste("MSE:", round(min(cv.out$cvm),3)) # Este es el MSE promedio de los 10 folds
```

Los coeficientes resultantes del modelo ajustado son:
  
```{r}
coef(cv.out, s = "lambda.min")
```

Finalmente, la ecuación propuesta por este modelo para estimar la talla en adultos mayores es:

$$Talla = 65.62 + 2.18 \cdot LRM\_90 - 0.09 \cdot Edad + 4.78 \cdot Sexo + 0.19 \cdot Ind + 0.51 \cdot Rrom$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\
$$Ind = \begin{cases} 1 & \text{si Etnia = Indígena} \\ 0 & \text{en otro caso} \end{cases}$$\
$$Rrom = \begin{cases} 1 & \text{si Etnia = Rrom} \\ 0 & \text{en otro caso} \end{cases}$$

### Resumen modelos LASSO

En general, los modelos ajustados incluyeron más variables que las tres del modelo normal (edad, sexo y mediciones). Cada modelo produjo diferentes estimaciones para los parámetros, lo que resulta en ecuaciones distintas para estimar la talla de los adultos mayores.

Nuevamente, es preferible el modelo LASSO que tenga menor error cuadrático medio. Y en general, es preferible el modelo (normal o LASSO) que tenga menor MSE.

La tabla de los errores cuadráticos medios de los modelos ajustados hasta el momento es: 

```{r}
MSEs[5:8,]
```

El modelo normal con LRT_A sigue siendo el mejor, ya que hasta el momento es el que presenta el menor MSE. Por lo tanto, no se procederá a verificar los supuestos para ninguno de los modelos LASSO, dado que el modelo normal continúa siendo superior.

## Modelo Gamma

### LRT Antropómetro

Inicialmente, se ajusta el modelo Gamma que incluye a todas las variables regresoras que se cree influyen en la estimación de la talla. 

```{r}
# Modelo nulo
gamma.reg_null <- glm(Talla ~ 1, family= Gamma(),data = datos)

# Estimacion del modelo
gamma.reg <- glm(Talla ~ LRT_A + Edad + Etnia + Sexo, family= Gamma(),data = datos)
summary(gamma.reg)

```

A continuación se realiza una selección de variables con el método "forward" de tal forma que se minimice el AIC. El modelo seleccionado resulta ser el que incluye Edad, Sexo y LRT_A.

```{r}
stepwise <- stepAIC(gamma.reg_null, scope = list(lower = gamma.reg_null, upper = gamma.reg), trace = TRUE, k= 2, direction="forward") # k= log(nrow(datos)) - BIC
```
Los coeficientes del modelo son

```{r}
# Estimacion del modelo
gamma.final <- glm(Talla ~ LRT_A + Edad + Sexo, family= Gamma(),data = datos)
summary(gamma.final)
```
Entonces, la ecuación propuesta por este modelo para estimar el logaritmo de la talla en adultos mayores es:

$$\ln(Talla) = 0.01035 - 0.00008776 \cdot LRT\_A + 0.000004417 \cdot Edad - 0.0001370 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\

Se utiliza el método de***k-fold cross validation*** con $k = 10$ y y se calcula el promedio del MSE obtenido en cada iteración. El MSE para este modelo es:

```{r}
# k folds
best.fit <- pred <- CV.ERRORS <- cv.errors <- NULL

set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- glm(Talla ~ LRT_A + Edad + Sexo, family= Gamma(), data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data, type = "response")

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

```{r}
# Error cuadratico medio
mean(errores)

# Hacer predicciones en test
predicciones_test <- predict(gamma.final, newdata = test, type = "response")

# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Gamma", Medida = "LRT_A", MSE = mean(errores), MSE_validacion = MSE_test))
```

### LRT cinta métrica

Inicialmente, se ajusta el modelo Gamma que incluye a todas las variables regresoras que se cree influyen en la estimación de la talla. 

```{r}
# Modelo nulo
gamma.reg_null <- glm(Talla ~ 1, family= Gamma(),data = datos)

# Estimacion del modelo
gamma.reg <- glm(Talla ~ LRT_CM + Edad + Etnia + Sexo, family= Gamma(),data = datos)
summary(gamma.reg)

```

A continuación se realiza una selección de variables con el método "forward" de tal forma que se minimice el AIC. El modelo seleccionado resulta ser el que incluye Edad, Sexo y LRT_A.

```{r}
stepwise <- stepAIC(gamma.reg_null, scope = list(lower = gamma.reg_null, upper = gamma.reg), trace = TRUE, k= 2, direction="forward") # k= log(nrow(datos)) - BIC
```

Los coeficientes del modelo son

```{r}
# Estimacion del modelo
gamma.final <- glm(Talla ~ LRT_CM + Edad + Sexo, family= Gamma(),data = datos)
summary(gamma.final)
```

Entonces, la ecuación propuesta por este modelo para estimar el logaritmo de la talla en adultos mayores es:

$$\ln(Talla) = 0.01045 - 0.00008680 \cdot LRT\_CM + 0.000004502 \cdot Edad - 0.0001797 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\

Se utiliza el método de***k-fold cross validation*** con $k = 10$ y y se calcula el promedio del MSE obtenido en cada iteración. El MSE para este modelo es:

```{r}
# k folds
best.fit <- pred <- CV.ERRORS <- cv.errors <- NULL

set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- glm(Talla ~ LRT_CM + Edad + Sexo, family= Gamma(), data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data, type = "response")

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

```{r}
# Error cuadratico medio
mean(errores)

# Hacer predicciones en test
predicciones_test <- predict(gamma.final, newdata = test, type = "response")

# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Gamma", Medida = "LRT_CM", MSE = mean(errores), MSE_validacion = MSE_test))
```

### LRM pierna estirada

Inicialmente, se ajusta el modelo Gamma que incluye a todas las variables regresoras que se cree influyen en la estimación de la talla. 

```{r}
# Modelo nulo
gamma.reg_null <- glm(Talla ~ 1, family= Gamma(),data = datos)

# Estimacion del modelo
gamma.reg <- glm(Talla ~ LRM_R + Edad + Etnia + Sexo, family= Gamma(),data = datos)
summary(gamma.reg)

```

A continuación se realiza una selección de variables con el método "forward" de tal forma que se minimice el AIC. El modelo seleccionado resulta ser el que incluye Edad, Sexo y LRT_A.

```{r}
stepwise <- stepAIC(gamma.reg_null, scope = list(lower = gamma.reg_null, upper = gamma.reg), trace = TRUE, k= 2, direction="forward") # k= log(nrow(datos)) - BIC
```

Los coeficientes del modelo son

```{r}
# Estimacion del modelo
gamma.final <- glm(Talla ~ LRM_R + Edad + Sexo, family= Gamma(),data = datos)
summary(gamma.final)
```

Entonces, la ecuación propuesta por este modelo para estimar el logaritmo de la talla en adultos mayores es:

$$\ln(Talla) = 0.01002 - 0.00008954 \cdot LRM\_R + 0.000004103 \cdot Edad - 0.0001579 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\

Se utiliza el método de***k-fold cross validation*** con $k = 10$ y y se calcula el promedio del MSE obtenido en cada iteración. El MSE para este modelo es:

```{r}
# k folds
best.fit <- pred <- CV.ERRORS <- cv.errors <- NULL

set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- glm(Talla ~ LRM_R + Edad + Sexo, family= Gamma(), data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data, type = "response")

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

```{r}
# Error cuadratico medio
mean(errores)

# Hacer predicciones en test
predicciones_test <- predict(gamma.final, newdata = test, type = "response")

# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Gamma", Medida = "LRM_R", MSE = mean(errores), MSE_validacion = MSE_test))
```

### LRM pierna 90°

Inicialmente, se ajusta el modelo Gamma que incluye a todas las variables regresoras que se cree influyen en la estimación de la talla. 

```{r}
# Modelo nulo
gamma.reg_null <- glm(Talla ~ 1, family= Gamma(),data = datos)

# Estimacion del modelo
gamma.reg <- glm(Talla ~ LRM_90 + Edad + Etnia + Sexo, family= Gamma(),data = datos)
summary(gamma.reg)

```

A continuación se realiza una selección de variables con el método "forward" de tal forma que se minimice el AIC. El modelo seleccionado resulta ser el que incluye Edad, Sexo y LRT_A.

```{r}
stepwise <- stepAIC(gamma.reg_null, scope = list(lower = gamma.reg_null, upper = gamma.reg), trace = TRUE, k= 2, direction="forward") # k= log(nrow(datos)) - BIC
```

Los coeficientes del modelo son

```{r}
# Estimacion del modelo
gamma.final <- glm(Talla ~ LRM_90 + Edad + Sexo, family= Gamma(),data = datos)
summary(gamma.final)
```

Entonces, la ecuación propuesta por este modelo para estimar el logaritmo de la talla en adultos mayores es:

$$\ln(Talla) = 0.01009 - 0.00008884 \cdot LRT\_A + 0.000003964 \cdot Edad - 0.0002038 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = Masculino} \\ 0 & \text{si sexo = Femenino} \end{cases}$$\

Se utiliza el método de***k-fold cross validation*** con $k = 10$ y y se calcula el promedio del MSE obtenido en cada iteración. El MSE para este modelo es:

```{r}
# k folds
best.fit <- pred <- CV.ERRORS <- cv.errors <- NULL

set.seed(123)  # Semilla para reproducibilidad
folds <- vfold_cv(datos, v = 10)

# Inicializar lista para almacenar errores
errores <- numeric(length(folds$splits))

# Loop para entrenar y validar el modelo en cada fold
for (i in seq_along(folds$splits)) {
  # Dividir datos
  train_data <- analysis(folds$splits[[i]])  # Datos de entrenamiento
  test_data <- assessment(folds$splits[[i]]) # Datos de validación

  # Ajustar el modelo
  modelo <- glm(Talla ~ LRM_90 + Edad + Sexo, family= Gamma(), data = train_data)

  # Predicciones
  predicciones <- predict(modelo, newdata = test_data, type = "response")

  # Calcular error cuadrático medio
  errores[i] <- mean((test_data$Talla - predicciones)^2)
}
```

```{r}
# Error cuadratico medio
mean(errores)

# Hacer predicciones en test
predicciones_test <- predict(gamma.final, newdata = test, type = "response")

# Calcular el MSE en test
MSE_test <- mean((test$Talla - predicciones_test)^2)

MSEs <- rbind(MSEs, data.frame(Modelo = "Gamma", Medida = "LRM_90", MSE = mean(errores), MSE_validacion = MSE_test))
```

### Resumen modelos Gamma

En general, los modelos Gamma ajustados incluyeron las mismas tres variables del modelo normal (edad, sexo y mediciones). Cada modelo produjo diferentes estimaciones para los parámetros, lo que resulta en ecuaciones distintas para estimar la talla de los adultos mayores.

De nuevo, es preferible el modelo Gamma que tenga menor error cuadrático medio. Y en general, es preferible el modelo (normal, LASSO o Gamma) que tenga menor MSE.

La tabla de los errores cuadráticos medios de los modelos ajustados hasta el momento es:

```{r}
MSEs[1:12,]
```

El modelo normal con LRT_A sigue siendo el mejor, ya que hasta el momento es el que presenta el menor MSE. Por lo tanto, no se procederá a verificar los supuestos para ninguno de los modelos Gamma, dado que el modelo normal continúa siendo superior.

## Propuesta: Nuevas fórmulas

Dado que el modelo ajustado con menor error cuadrático medio es el normal con LRT con antropómetro, la fórmula que se propone en esta investigación para realizar la estimación de la talla de adultos mayores en Colombia es 

$$Talla = 58.84 + 2.17 \cdot LRT\_A - 0.11 \cdot Edad + 3.22 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = masculino} \\ 0 & \text{si sexo = femenino} \end{cases}$$

Que también puede verse como dos fórmulas, una para cada sexo:

*   Sexo masculino: $Talla = 62.06 + 2.17 LRT\_A - 0.11 Edad$, la interpretación de cada parámetro es: 
    +   Intercepto: Suponiendo el caso hipotético en que un adulto mayor tenga $LRT\_A = 0$ y $Edad = 0$, entonces la talla estimada para ese adulto mayor de sexo masculino es $62.06$ centímetros.
    +   LRT_A: Por cada centímetro adicional que mida la LRT_A del adulto mayor masculino, entonces la estimación de su talla aumenta $2.17$ centímetros.
    +   Edad: Por cada año cumplido adicional que tenga el adulto mayor de sexo masculino, la estimación de su talla disminuye $0.11$ centímetros.
    
*   Sexo femenino: $Talla = 58.84 + 2.17 LRT\_A - 0.11 Edad$, la interpretación de cada parámetro es:
    +   Intercepto: Suponiendo el caso hipotético en que un adulto mayor tenga $LRT\_A = 0$ y $Edad = 0$, entonces la talla estimada para ese adulto mayor de sexo femenino es $58.84$ centímetros.
    +   LRT_A: Por cada centímetro adicional que mida la LRT_A del adulto mayor femenino, entonces la estimación de su talla aumenta $2.17$ centímetros.
    +   Edad: Por cada año cumplido adicional que tenga el adulto mayor de sexo femenino, la estimación de su talla disminuye $0.11$ centímetros.


## Fórmulas Benjumea

Se calculan las estimaciones de las tallas a partir de las fórmulas de Benjumea, esto para compararlas con las estimaciones de la fórmula propuesta en esta investigación.

Las fórmulas de Benjumea son:

*   Indígena masculino: $82.695 + 1.745 LRT_A - 0.121 Edad$

*   Indígena femenino: $90.281 + 1.436 LRT_A - 0.102 Edad$

*   Afrodescendiente masculino: $9.298 + 1.855 LRT_A - 0.141 Edad$

*   Afrodescendiente femenino: $76.233 + 1.767 LRT_A - 0.098 Edad$

*   Blanco-Mestizo masculino: $75.514 + 1.883 LRT_A - 0.108 Edad$

*   Blanco-Mestizo femenino: $86.497 + 1.553 LRT_A - 0.119 Edad$

Cabe resaltar que no existe fórmula para la etnia Rrom, por lo que hubo un individuo en la muestra a quien no fue posible realizar la estimación por medio de las fórmulas de Benjumea.

### LRT Antropómetro

Las fórmulas de Benjumea tienen en cuenta la medición LRT. El error cuadrático medio de las fórmulas de Benjumea con LRT_A es 

```{r}
# LRT_A
datos$Benjumea_LRT_A = rep(NA,nrow(datos))

# Indigena masculino
datos$Benjumea_LRT_A = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Indigena", 82.695 + 1.745*datos$LRT_A - 0.121*datos$Edad, datos$Benjumea_LRT_A)
# Indigena femenino
datos$Benjumea_LRT_A = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Indigena", 90.281 + 1.436*datos$LRT_A - 0.102*datos$Edad, datos$Benjumea_LRT_A)
# Afrodescendiente masculino
datos$Benjumea_LRT_A = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Afrocolombiano", 79.298 + 1.855*datos$LRT_A - 0.141*datos$Edad, datos$Benjumea_LRT_A)
# Afrodescendiente femenino
datos$Benjumea_LRT_A = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Afrocolombiano", 76.233 + 1.767*datos$LRT_A - 0.098*datos$Edad, datos$Benjumea_LRT_A)
# Blanco-Mestizo masculino
datos$Benjumea_LRT_A = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Blanco-Mestizo", 75.514 + 1.883*datos$LRT_A - 0.108*datos$Edad, datos$Benjumea_LRT_A)
# Blanco-Mestizo femenino
datos$Benjumea_LRT_A = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Blanco-Mestizo", 86.497 + 1.553*datos$LRT_A - 0.119*datos$Edad, datos$Benjumea_LRT_A)

mean((datos$Talla - datos$Benjumea_LRT_A)^2, na.rm = TRUE)
```

```{r}
test$Benjumea_LRT_A <- rep(NA, nrow(test))

# Indigena masculino
test$Benjumea_LRT_A <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Indigena", 
                              82.695 + 1.745 * test$LRT_A - 0.121 * test$Edad, test$Benjumea_LRT_A)
# Indigena femenino
test$Benjumea_LRT_A <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Indigena", 
                              90.281 + 1.436 * test$LRT_A - 0.102 * test$Edad, test$Benjumea_LRT_A)
# Afrodescendiente masculino
test$Benjumea_LRT_A <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Afrocolombiano", 
                              79.298 + 1.855 * test$LRT_A - 0.141 * test$Edad, test$Benjumea_LRT_A)
# Afrodescendiente femenino
test$Benjumea_LRT_A <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Afrocolombiano", 
                              76.233 + 1.767 * test$LRT_A - 0.098 * test$Edad, test$Benjumea_LRT_A)
# Blanco-Mestizo masculino
test$Benjumea_LRT_A <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Blanco-Mestizo", 
                              75.514 + 1.883 * test$LRT_A - 0.108 * test$Edad, test$Benjumea_LRT_A)
# Blanco-Mestizo femenino
test$Benjumea_LRT_A <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Blanco-Mestizo", 
                              86.497 + 1.553 * test$LRT_A - 0.119 * test$Edad, test$Benjumea_LRT_A)

# Calcular el MSE en test
MSE_test <- mean((test$Talla - test$Benjumea_LRT_A)^2, na.rm = TRUE)


MSEs <- rbind(MSEs, data.frame(Modelo = "Benjumea", Medida = "LRT_A", MSE = mean((datos$Talla - datos$Benjumea_LRT_A)^2, na.rm = TRUE), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
# LRT_A
datos_copia$Benjumea_LRT_A = rep(NA,nrow(datos_copia))

# Indigena masculino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Indigena", 82.695 + 1.745*datos_copia$LRT_A - 0.121*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
# Indigena femenino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Indigena", 90.281 + 1.436*datos_copia$LRT_A - 0.102*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
# Afrodescendiente masculino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Afrocolombiano", 79.298 + 1.855*datos_copia$LRT_A - 0.141*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
# Afrodescendiente femenino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Afrocolombiano", 76.233 + 1.767*datos_copia$LRT_A - 0.098*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
# Blanco-Mestizo masculino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Blanco-Mestizo", 75.514 + 1.883*datos_copia$LRT_A - 0.108*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
# Blanco-Mestizo femenino
datos_copia$Benjumea_LRT_A = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Blanco-Mestizo", 86.497 + 1.553*datos_copia$LRT_A - 0.119*datos_copia$Edad, datos_copia$Benjumea_LRT_A)
```


### LRT cinta métrica

Las fórmulas de Benjumea tienen en cuenta la medición LRT. El error cuadrático medio de las fórmulas de Benjumea con LRT_CM es 

```{r}
# LRT_CM
datos$Benjumea_LRT_CM = rep(NA,nrow(datos))

# Indigena masculino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Indigena", 82.695 + 1.745*datos$LRT_CM - 0.121*datos$Edad, datos$Benjumea_LRT_CM)
# Indigena femenino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Indigena", 90.281 + 1.436*datos$LRT_CM - 0.102*datos$Edad, datos$Benjumea_LRT_CM)
# Afrodescendiente masculino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Afrocolombiano", 79.298 + 1.855*datos$LRT_CM - 0.141*datos$Edad, datos$Benjumea_LRT_CM)
# Afrodescendiente femenino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Afrocolombiano", 76.233 + 1.767*datos$LRT_CM - 0.098*datos$Edad, datos$Benjumea_LRT_CM)
# Blanco-Mestizo masculino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo=="Masculino" & datos$Etnia == "Blanco-Mestizo", 75.514 + 1.883*datos$LRT_CM - 0.108*datos$Edad, datos$Benjumea_LRT_CM)
# Blanco-Mestizo femenino
datos$Benjumea_LRT_CM = ifelse(datos$Sexo!="Masculino" & datos$Etnia == "Blanco-Mestizo", 86.497 + 1.553*datos$LRT_CM - 0.119*datos$Edad, datos$Benjumea_LRT_CM)

mean((datos$Talla - datos$Benjumea_LRT_CM)^2, na.rm = TRUE)
```

```{r}
test$Benjumea_LRT_CM <- rep(NA, nrow(test))

# Indigena masculino
test$Benjumea_LRT_CM <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Indigena", 
                              82.695 + 1.745 * test$LRT_CM - 0.121 * test$Edad, test$Benjumea_LRT_CM)
# Indigena femenino
test$Benjumea_LRT_CM <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Indigena", 
                              90.281 + 1.436 * test$LRT_CM - 0.102 * test$Edad, test$Benjumea_LRT_CM)
# Afrodescendiente masculino
test$Benjumea_LRT_CM <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Afrocolombiano", 
                              79.298 + 1.855 * test$LRT_CM - 0.141 * test$Edad, test$Benjumea_LRT_CM)
# Afrodescendiente femenino
test$Benjumea_LRT_CM <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Afrocolombiano", 
                              76.233 + 1.767 * test$LRT_CM - 0.098 * test$Edad, test$Benjumea_LRT_CM)
# Blanco-Mestizo masculino
test$Benjumea_LRT_CM <- ifelse(test$Sexo == "Masculino" & test$Etnia == "Blanco-Mestizo", 
                              75.514 + 1.883 * test$LRT_CM - 0.108 * test$Edad, test$Benjumea_LRT_CM)
# Blanco-Mestizo femenino
test$Benjumea_LRT_CM <- ifelse(test$Sexo != "Masculino" & test$Etnia == "Blanco-Mestizo", 
                              86.497 + 1.553 * test$LRT_CM - 0.119 * test$Edad, test$Benjumea_LRT_CM)

# Calcular el MSE en test
MSE_test <- mean((test$Talla - test$Benjumea_LRT_CM)^2, na.rm = TRUE)


MSEs <- rbind(MSEs, data.frame(Modelo = "Benjumea", Medida = "LRT_CM", MSE = mean((datos$Talla - datos$Benjumea_LRT_CM)^2, na.rm = TRUE), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
# LRT_A
datos_copia$Benjumea_LRT_CM = rep(NA,nrow(datos_copia))

# Indigena masculino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Indigena", 82.695 + 1.745*datos_copia$LRT_CM - 0.121*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
# Indigena femenino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Indigena", 90.281 + 1.436*datos_copia$LRT_CM - 0.102*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
# Afrodescendiente masculino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Afrocolombiano", 79.298 + 1.855*datos_copia$LRT_CM - 0.141*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
# Afrodescendiente femenino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Afrocolombiano", 76.233 + 1.767*datos_copia$LRT_CM - 0.098*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
# Blanco-Mestizo masculino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo=="Masculino" & datos_copia$Etnia == "Blanco-Mestizo", 75.514 + 1.883*datos_copia$LRT_CM - 0.108*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
# Blanco-Mestizo femenino
datos_copia$Benjumea_LRT_CM = ifelse(datos_copia$Sexo!="Masculino" & datos_copia$Etnia == "Blanco-Mestizo", 86.497 + 1.553*datos_copia$LRT_CM - 0.119*datos_copia$Edad, datos_copia$Benjumea_LRT_CM)
```

### Resumen fórmulas Benjumea

La tabla de los errores cuadráticos medios con las fórmulas de Benjumea es:

```{r}
MSEs[13:14,]
```

Los MSE son mayores a los modelos ajustados anteriormente.

## Fórmulas Arango y Zamora

Se calculan las estimaciones de las tallas a partir de las fórmulas de Arango y Zamora, esto para compararlas con las estimaciones de la fórmula propuesta en esta investigación.

Las fórmulas de Arango y Zamora son:

*   Sexo masculino: $119.6 + 1.121 LRM_R - 0.117 Edad$
*   Sexo femenino: $107.7 + 1.263 LRM_R - 0.159 Edad$

### LRM pierna estirada

Las fórmulas de Arango y Zamora tienen en cuenta la medición LRM. El error cuadrático medio de las fórmulas de Arango y Zamora con LRM_R es 

```{r}
# LRM_R
datos$Arango_LRM_R = rep(NA,nrow(datos))

# Masculino
datos$Arango_LRM_R = ifelse(datos$Sexo=="Masculino", 119.6 + 1.121*datos$LRM_R - 0.117*datos$Edad, datos$Arango_LRM_R)
# Femenino
datos$Arango_LRM_R = ifelse(datos$Sexo!="Masculino", 107.7 + 1.263*datos$LRM_R - 0.159*datos$Edad, datos$Arango_LRM_R)

mean((datos$Talla - datos$Arango_LRM_R)^2, na.rm = TRUE)
```

```{r}
# LRM_R
test$Arango_LRM_R = rep(NA,nrow(test))

# Masculino
test$Arango_LRM_R = ifelse(test$Sexo=="Masculino", 119.6 + 1.121*test$LRM_R - 0.117*test$Edad, test$Arango_LRM_R)
# Femenino
test$Arango_LRM_R = ifelse(test$Sexo!="Masculino", 107.7 + 1.263*test$LRM_R - 0.159*test$Edad, test$Arango_LRM_R)

MSE_test <- mean((test$Talla - test$Arango_LRM_R)^2, na.rm = TRUE)

MSEs <- rbind(MSEs, data.frame(Modelo = "Arango, Zamora", Medida = "LRM_R", MSE = mean((datos$Talla - datos$Arango_LRM_R)^2, na.rm = TRUE), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
# LRM_R
datos_copia$Arango_LRM_R = rep(NA,nrow(datos_copia))

# Masculino
datos_copia$Arango_LRM_R = ifelse(datos_copia$Sexo=="Masculino", 119.6 + 1.121*datos_copia$LRM_R - 0.117*datos_copia$Edad, datos_copia$Arango_LRM_R)
# Femenino
datos_copia$Arango_LRM_R = ifelse(datos_copia$Sexo!="Masculino", 107.7 + 1.263*datos_copia$LRM_R - 0.159*datos_copia$Edad, datos_copia$Arango_LRM_R)
```

### LRM pierna a 90°

Las fórmulas de Arango y Zamora tienen en cuenta la medición LRM. El error cuadrático medio de las fórmulas de Arango y Zamora con LRM_90 es 

```{r}
# LRM_90
datos$Arango_LRM_90 = rep(NA,nrow(datos))

# Masculino
datos$Arango_LRM_90 = ifelse(datos$Sexo=="Masculino", 119.6 + 1.121*datos$LRM_90 - 0.117*datos$Edad, datos$Arango_LRM_90)
# Femenino
datos$Arango_LRM_90 = ifelse(datos$Sexo!="Masculino", 107.7 + 1.263*datos$LRM_90 - 0.159*datos$Edad, datos$Arango_LRM_90)

mean((datos$Talla - datos$Arango_LRM_90)^2, na.rm = TRUE)

```

```{r}
# LRM_R
test$Arango_LRM_90 = rep(NA,nrow(test))

# Masculino
test$Arango_LRM_90 = ifelse(test$Sexo=="Masculino", 119.6 + 1.121*test$LRM_90 - 0.117*test$Edad, test$Arango_LRM_90)
# Femenino
test$Arango_LRM_90 = ifelse(test$Sexo!="Masculino", 107.7 + 1.263*test$LRM_90 - 0.159*test$Edad, test$Arango_LRM_90)

MSE_test <- mean((test$Talla - test$Arango_LRM_90)^2, na.rm = TRUE)

MSEs <- rbind(MSEs, data.frame(Modelo = "Arango, Zamora", Medida = "LRM_90", MSE = mean((datos$Talla - datos$Arango_LRM_90)^2, na.rm = TRUE), MSE_validacion = MSE_test))
```


```{r}
# Para almacenar las estimaciones en un excel
# LRM_90
datos_copia$Arango_LRM_90 = rep(NA,nrow(datos_copia))

# Masculino
datos_copia$Arango_LRM_90 = ifelse(datos_copia$Sexo=="Masculino", 119.6 + 1.121*datos_copia$LRM_90 - 0.117*datos_copia$Edad, datos_copia$Arango_LRM_90)
# Femenino
datos_copia$Arango_LRM_90 = ifelse(datos_copia$Sexo!="Masculino", 107.7 + 1.263*datos_copia$LRM_90 - 0.159*datos_copia$Edad, datos_copia$Arango_LRM_90)
```


```{r}
#| eval: false
# Escribimos el excel con las estimaciones

library(writexl)

write_xlsx(datos_copia[,-1], "Estimaciones.xlsx")
```

### Resumen fórmulas Arango y Zamora

La tabla de los errores cuadráticos medios con las fórmulas de Benjumea es:

```{r}
MSEs[15:16,]
```

Los MSE son mayores a los modelos ajustados anteriormente.

## Conclusión 

A continuación, se muestra la tabla de los MSE de todos los modelos ajustados en la investigación y de las fórmulas de Benjumea y de Arango y Zamora.

```{r}
MSEs
```

Se observa que el modelo que presenta menor MSE es el modelo normal con LRT con antropómetro, de modo que, se concluye que este es el mejor modelo pues sus estimaciones de la talla son más cercanas a la verdadera talla del adulto mayor. 

::: {.callout-note}

Por lo que las fórmulas que mejor estiman la talla de los adultos mayores en Colombia, según la base de datos analizada, son:

$$Talla = 58.84 + 2.17 \cdot LRT\_A - 0.11 \cdot Edad + 3.22 \cdot Sexo$$\
$$Sexo = \begin{cases} 1 & \text{si sexo = masculino} \\ 0 & \text{si sexo = femenino} \end{cases}$$

:::


## Comportamiento de las variables de interés por subgrupos

A continuación se mestra un resumen de las variables Edad, Talla, LRT_A y LRT_CM para cada subgrupo (femenino o masculino) de la muestra. Dentro de las medidas de resumen se encuentran tamaño de la muestra ($n$), mínimo, máximo, promedio, desviación estándar (DesEst) y mediana del grupo de datos con el que se ajustaron los modelos, además, estas mismas mediciones para el grupo de datos con el que se vaidaron los modelos (n_val, Minimo_val, Maximo_val, Promedio_val, DesEst_val, Mediana_val), y también el valor p (P_valor) de la prueba de independencia U de Mann-Whitney para Edad, o de la prueba $t$ de independencia para Talla, LRT_A y LRT_CM.

### Sexo femenino

```{r}
femenino_tab <- data.frame(Variable = character(),
                           n = numeric(),
                           Minimo = numeric(),
                           Maximo = numeric(),
                           Promedio = numeric(),
                           DesEst = numeric(),
                           Mediana = numeric(),
                           n_val = numeric(),
                           Minimo_val = numeric(),
                           Maximo_val = numeric(),
                           Promedio_val = numeric(),
                           DesEst_val = numeric(),
                           Mediana_val = numeric(),
                           P_valor = numeric())

femenino <- datos[datos$Sexo == "Femenino",]
femenino_test <- test[test$Sexo == "Femenino",]
```


```{r}
#| results: hide
lillie.test(femenino$Edad) # No normalidad
lillie.test(femenino_test$Edad) # No normalidad


lillie.test(femenino$Talla) # Normalidad
lillie.test(femenino_test$Talla) # Normalidad

lillie.test(femenino$LRT_A) # Normalidad
lillie.test(femenino_test$LRT_A) # Normalidad

lillie.test(femenino$LRT_CM) # Normalidad
lillie.test(femenino_test$LRT_CM) # Normalidad

lillie.test(femenino$LRM_R) # Normalidad
lillie.test(femenino_test$LRM_R) # Normalidad

lillie.test(femenino$LRM_90) # Normalidad
lillie.test(femenino_test$LRM_90) # Normalidad
```


```{r}
femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "Edad",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$Edad),
                                 Maximo = max(femenino$Edad),
                                 Promedio = mean(femenino$Edad),
                                 DesEst = sd(femenino$Edad),
                                 Mediana = median(femenino$Edad),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$Edad),
                                 Maximo_val = max(femenino_test$Edad),
                                 Promedio_val = mean(femenino_test$Edad),
                                 DesEst_val = sd(femenino_test$Edad),
                                 Mediana_val = median(femenino_test$Edad),
                                 P_valor = wilcox.test(femenino$Edad, femenino_test$Edad)$p.value))

femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "Talla",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$Talla),
                                 Maximo = max(femenino$Talla),
                                 Promedio = mean(femenino$Talla),
                                 DesEst = sd(femenino$Talla),
                                 Mediana = median(femenino$Talla),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$Talla),
                                 Maximo_val = max(femenino_test$Talla),
                                 Promedio_val = mean(femenino_test$Talla),
                                 DesEst_val = sd(femenino_test$Talla),
                                 Mediana_val = median(femenino_test$Talla),
                                 P_valor = t.test(femenino$Talla, femenino_test$Talla)$p.value))

femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "LRT_A",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$LRT_A),
                                 Maximo = max(femenino$LRT_A),
                                 Promedio = mean(femenino$LRT_A),
                                 DesEst = sd(femenino$LRT_A),
                                 Mediana = median(femenino$LRT_A),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$LRT_A),
                                 Maximo_val = max(femenino_test$LRT_A),
                                 Promedio_val = mean(femenino_test$LRT_A),
                                 DesEst_val = sd(femenino_test$LRT_A),
                                 Mediana_val = median(femenino_test$LRT_A),
                                 P_valor = t.test(femenino$LRT_A, femenino_test$LRT_A)$p.value))

femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "LRT_CM",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$LRT_CM),
                                 Maximo = max(femenino$LRT_CM),
                                 Promedio = mean(femenino$LRT_CM),
                                 DesEst = sd(femenino$LRT_CM),
                                 Mediana = median(femenino$LRT_CM),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$LRT_CM),
                                 Maximo_val = max(femenino_test$LRT_CM),
                                 Promedio_val = mean(femenino_test$LRT_CM),
                                 DesEst_val = sd(femenino_test$LRT_CM),
                                 Mediana_val = median(femenino_test$LRT_CM),
                                 P_valor = t.test(femenino$LRT_CM, femenino_test$LRT_CM)$p.value))


femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "LRM_R",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$LRM_R),
                                 Maximo = max(femenino$LRM_R),
                                 Promedio = mean(femenino$LRM_R),
                                 DesEst = sd(femenino$LRM_R),
                                 Mediana = median(femenino$LRM_R),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$LRM_R),
                                 Maximo_val = max(femenino_test$LRM_R),
                                 Promedio_val = mean(femenino_test$LRM_R),
                                 DesEst_val = sd(femenino_test$LRM_R),
                                 Mediana_val = median(femenino_test$LRM_R),
                                 P_valor = wilcox.test(femenino$LRM_R, femenino_test$LRM_R)$p.value))

femenino_tab <- rbind(femenino_tab, 
                      data.frame(Variable = "LRM_90",
                                 n = nrow(femenino),
                                 Minimo = min(femenino$LRM_90),
                                 Maximo = max(femenino$LRM_90),
                                 Promedio = mean(femenino$LRM_90),
                                 DesEst = sd(femenino$LRM_90),
                                 Mediana = median(femenino$LRM_90),
                                 n_val = nrow(femenino_test),
                                 Minimo_val = min(femenino_test$LRM_90),
                                 Maximo_val = max(femenino_test$LRM_90),
                                 Promedio_val = mean(femenino_test$LRM_90),
                                 DesEst_val = sd(femenino_test$LRM_90),
                                 Mediana_val = median(femenino_test$LRM_90),
                                 P_valor = wilcox.test(femenino$LRM_90, femenino_test$LRM_90)$p.value))



femenino_tab |> gt()
```

### Sexo masculino

```{r}
masculino_tab <- data.frame(Variable = character(),
                           n = numeric(),
                           Minimo = numeric(),
                           Maximo = numeric(),
                           Promedio = numeric(),
                           DesEst = numeric(),
                           Mediana = numeric(),
                           n_val = numeric(),
                           Minimo_val = numeric(),
                           Maximo_val = numeric(),
                           Promedio_val = numeric(),
                           DesEst_val = numeric(),
                           Mediana_val = numeric(),
                           P_valor = numeric())

masculino <- datos[datos$Sexo == "Masculino",]
masculino_test <- test[test$Sexo == "Masculino",]
```

```{r}
#| results: hide
lillie.test(masculino$Edad) # No normalidad
lillie.test(masculino_test$Edad) # No normalidad


lillie.test(masculino$Talla) # Normalidad
lillie.test(masculino_test$Talla) # Normalidad

lillie.test(masculino$LRT_A) # Normalidad
lillie.test(masculino_test$LRT_A) # Normalidad

lillie.test(masculino$LRT_CM) # Normalidad
lillie.test(masculino_test$LRT_CM) # Normalidad

lillie.test(masculino$LRM_R) # Normalidad
lillie.test(masculino_test$LRM_R) # Normalidad

lillie.test(masculino$LRM_90) # Normalidad
lillie.test(masculino_test$LRM_90) # Normalidad
```


```{r}
masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "Edad",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$Edad),
                                 Maximo = max(masculino$Edad),
                                 Promedio = mean(masculino$Edad),
                                 DesEst = sd(masculino$Edad),
                                 Mediana = median(masculino$Edad),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$Edad),
                                 Maximo_val = max(masculino_test$Edad),
                                 Promedio_val = mean(masculino_test$Edad),
                                 DesEst_val = sd(masculino_test$Edad),
                                 Mediana_val = median(masculino_test$Edad),
                                 P_valor = wilcox.test(masculino$Edad, masculino_test$Edad)$p.value))

masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "Talla",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$Talla),
                                 Maximo = max(masculino$Talla),
                                 Promedio = mean(masculino$Talla),
                                 DesEst = sd(masculino$Talla),
                                 Mediana = median(masculino$Talla),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$Talla),
                                 Maximo_val = max(masculino_test$Talla),
                                 Promedio_val = mean(masculino_test$Talla),
                                 DesEst_val = sd(masculino_test$Talla),
                                 Mediana_val = median(masculino_test$Talla),
                                 P_valor = t.test(masculino$Talla, masculino_test$Talla)$p.value))

masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "LRT_A",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$LRT_A),
                                 Maximo = max(masculino$LRT_A),
                                 Promedio = mean(masculino$LRT_A),
                                 DesEst = sd(masculino$LRT_A),
                                 Mediana = median(masculino$LRT_A),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$LRT_A),
                                 Maximo_val = max(masculino_test$LRT_A),
                                 Promedio_val = mean(masculino_test$LRT_A),
                                 DesEst_val = sd(masculino_test$LRT_A),
                                 Mediana_val = median(masculino_test$LRT_A),
                                 P_valor = t.test(masculino$LRT_A, masculino_test$LRT_A)$p.value))

masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "LRT_CM",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$LRT_CM),
                                 Maximo = max(masculino$LRT_CM),
                                 Promedio = mean(masculino$LRT_CM),
                                 DesEst = sd(masculino$LRT_CM),
                                 Mediana = median(masculino$LRT_CM),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$LRT_CM),
                                 Maximo_val = max(masculino_test$LRT_CM),
                                 Promedio_val = mean(masculino_test$LRT_CM),
                                 DesEst_val = sd(masculino_test$LRT_CM),
                                 Mediana_val = median(masculino_test$LRT_CM),
                                 P_valor = t.test(masculino$LRT_CM, masculino_test$LRT_CM)$p.value))

masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "LRM_R",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$LRM_R),
                                 Maximo = max(masculino$LRM_R),
                                 Promedio = mean(masculino$LRM_R),
                                 DesEst = sd(masculino$LRM_R),
                                 Mediana = median(masculino$LRM_R),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$LRM_R),
                                 Maximo_val = max(masculino_test$LRM_R),
                                 Promedio_val = mean(masculino_test$LRM_R),
                                 DesEst_val = sd(masculino_test$LRM_R),
                                 Mediana_val = median(masculino_test$LRM_R),
                                 P_valor = t.test(masculino$LRM_R, masculino_test$LRM_R)$p.value))

masculino_tab <- rbind(masculino_tab, 
                      data.frame(Variable = "LRM_90",
                                 n = nrow(masculino),
                                 Minimo = min(masculino$LRM_90),
                                 Maximo = max(masculino$LRM_90),
                                 Promedio = mean(masculino$LRM_90),
                                 DesEst = sd(masculino$LRM_90),
                                 Mediana = median(masculino$LRM_90),
                                 n_val = nrow(masculino_test),
                                 Minimo_val = min(masculino_test$LRM_90),
                                 Maximo_val = max(masculino_test$LRM_90),
                                 Promedio_val = mean(masculino_test$LRM_90),
                                 DesEst_val = sd(masculino_test$LRM_90),
                                 Mediana_val = median(masculino_test$LRM_90),
                                 P_valor = t.test(masculino$LRM_90, masculino_test$LRM_90)$p.value))

masculino_tab |> gt()
```

## Cuadro Modelos predicción de la talla por sexo

### Opción 1: Modelo normal LRT_A

A continuación se muestran los resultados del mejor modelo (normal con LRT_A) dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())

modelo_femenino <- lm(Talla ~ LRT_A + Edad, data = femenino)
r2_femenino <- summary(modelo_femenino)$r.squared
ee_femenino <- sqrt(mean(residuals(modelo_femenino)^2))
normalidad_femenino <- lillie.test(residuals(modelo_femenino))$p.value
homocedasticidad_femenino <- bptest(modelo_femenino)$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))

modelo_masculino <- lm(Talla ~ LRT_A + Edad, data = masculino)
r2_masculino <- summary(modelo_masculino)$r.squared
ee_masculino <- sqrt(mean(residuals(modelo_masculino)^2))
normalidad_masculino <- lillie.test(residuals(modelo_masculino))$p.value
homocedasticidad_masculino <- bptest(modelo_masculino)$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))


nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)
modelos_tab |> gt()
```


### Opción 2: Modelo normal LRT_CM

A continuación se muestran los resultados del SEGUNDO mejor modelo (normal con LRT_CM) dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())

modelo_femenino <- lm(Talla ~ LRT_CM + Edad, data = femenino)
r2_femenino <- summary(modelo_femenino)$r.squared
ee_femenino <- sqrt(mean(residuals(modelo_femenino)^2))
normalidad_femenino <- lillie.test(residuals(modelo_femenino))$p.value
homocedasticidad_femenino <- bptest(modelo_femenino)$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))

modelo_masculino <- lm(Talla ~ LRT_CM + Edad, data = masculino)
r2_masculino <- summary(modelo_masculino)$r.squared
ee_masculino <- sqrt(mean(residuals(modelo_masculino)^2))
normalidad_masculino <- lillie.test(residuals(modelo_masculino))$p.value
homocedasticidad_masculino <- bptest(modelo_masculino)$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))

nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)

modelos_tab |> gt()
```

### Opción 3: Fórmulas de Benjumea LRT_A

A continuación se muestran los resultados utilizando las fórmulas de Benjumea con LRT_A dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())

estimaciones <- read_xlsx("Datos/Estimaciones.xlsx")

# Femenino
train2 <- estimaciones[indices, ] 
femenino2 <- train2[train2$Sexo == "Femenino",]

# Residuales
residuos <- femenino2$Talla - femenino2$Benjumea_LRT_A

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino2$Talla - mean(femenino2$Talla))^2)  # Suma total de cuadrados
r2_femenino <- 1 - (SSE / SST)

# Error estandar
ee_femenino <- sqrt(mean(residuos^2))

# Prueba de normalidad sobre los residuales
normalidad_femenino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_femenino <- bptest(lm(residuos ~ LRT_A + Edad + Etnia, data = femenino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))



# Masculino
masculino2 <- train2[train2$Sexo == "Masculino",]

# Residuales
residuos <- masculino2$Talla - masculino2$Benjumea_LRT_A

# R cuadrado
SSE <- sum(residuos^2, na.rm = TRUE)  # Suma de errores cuadráticos
SST <- sum((masculino2$Talla - mean(masculino2$Talla))^2)  # Suma total de cuadrados
r2_masculino <- 1 - (SSE / SST)

# Error estandar
ee_masculino <- sqrt(mean(residuos^2, na.rm = TRUE))

# Prueba de normalidad sobre los residuales
normalidad_masculino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_masculino <- bptest(lm(residuos ~ LRT_A + Edad + Etnia, data = masculino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))

nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)

modelos_tab |> gt()
```


### Opción 4: Fórmulas de Benjumea LRT_CM

A continuación se muestran los resultados utilizando las fórmulas de Benjumea con LRT_CM dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())
# Femenino

# Residuales
residuos <- femenino2$Talla - femenino2$Benjumea_LRT_CM

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino2$Talla - mean(femenino2$Talla))^2)  # Suma total de cuadrados
r2_femenino <- 1 - (SSE / SST)

# Error estandar
ee_femenino <- sqrt(mean(residuos^2))

# Prueba de normalidad sobre los residuales
normalidad_femenino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_femenino <- bptest(lm(residuos ~ LRT_A + Edad + Etnia, data = femenino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))



# Masculino

# Residuales
residuos <- masculino2$Talla - masculino2$Benjumea_LRT_CM

# R cuadrado
SSE <- sum(residuos^2, na.rm = TRUE)  # Suma de errores cuadráticos
SST <- sum((masculino2$Talla - mean(masculino2$Talla))^2)  # Suma total de cuadrados
r2_masculino <- 1 - (SSE / SST)

# Error estandar
ee_masculino <- sqrt(mean(residuos^2, na.rm = TRUE))

# Prueba de normalidad sobre los residuales
normalidad_masculino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_masculino <- bptest(lm(residuos ~ LRT_A + Edad + Etnia, data = masculino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))

nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)

modelos_tab |> gt()
```


### Opción 5: Fórmulas de Arango y Zamora LRM_R

A continuación se muestran los resultados utilizando las fórmulas de Arango y Zamora con LRM_R (pierna estirada) dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())

# Femenino

# Residuales
residuos <- femenino2$Talla - femenino2$Arango_LRM_R

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino2$Talla - mean(femenino2$Talla))^2)  # Suma total de cuadrados
r2_femenino <- 1 - (SSE / SST)

# Error estandar
ee_femenino <- sqrt(mean(residuos^2))

# Prueba de normalidad sobre los residuales
normalidad_femenino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_femenino <- bptest(lm(residuos ~ LRT_A + Edad, data = femenino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))



# Masculino

# Residuales
residuos <- masculino2$Talla - masculino2$Arango_LRM_R

# R cuadrado
SSE <- sum(residuos^2, na.rm = TRUE)  # Suma de errores cuadráticos
SST <- sum((masculino2$Talla - mean(masculino2$Talla))^2)  # Suma total de cuadrados
r2_masculino <- 1 - (SSE / SST)

# Error estandar
ee_masculino <- sqrt(mean(residuos^2, na.rm = TRUE))

# Prueba de normalidad sobre los residuales
normalidad_masculino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_masculino <- bptest(lm(residuos ~ LRT_A + Edad, data = masculino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))

nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)

modelos_tab |> gt()
```


### Opción 6: Fórmulas de Arango y Zamora LRM_90

A continuación se muestran los resultados utilizando las fórmulas de Arango y Zamora con LRM_90 dentro del conjunto de entrenamiento, de modo que se muestra el tamaño de la muestra de entrenamiento ($n$), el *r-*cuadrado que muestra la varianza explciada por el modelo (R2), el error estándar de la estimación (EE), el valor p de la prueba de normalidad de Lilliefors (Normalidad), y el valor p de la prueba Breusch-Pagan para homocedasticidad (Homocedasticidad).

```{r}
modelos_tab <- data.frame(n = numeric(),
                          R2 = numeric(),
                          EE = numeric(),
                          Normalidad = numeric(),
                          Homocedasticidad = numeric())

# Femenino

# Residuales
residuos <- femenino2$Talla - femenino2$Arango_LRM_90

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino2$Talla - mean(femenino2$Talla))^2)  # Suma total de cuadrados
r2_femenino <- 1 - (SSE / SST)

# Error estandar
ee_femenino <- sqrt(mean(residuos^2))

# Prueba de normalidad sobre los residuales
normalidad_femenino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_femenino <- bptest(lm(residuos ~ LRT_A + Edad, data = femenino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(femenino),
                                R2 = r2_femenino,
                                EE = ee_femenino,
                                Normalidad = normalidad_femenino,
                                Homocedasticidad = homocedasticidad_femenino))



# Masculino

# Residuales
residuos <- masculino2$Talla - masculino2$Arango_LRM_90

# R cuadrado
SSE <- sum(residuos^2, na.rm = TRUE)  # Suma de errores cuadráticos
SST <- sum((masculino2$Talla - mean(masculino2$Talla))^2)  # Suma total de cuadrados
r2_masculino <- 1 - (SSE / SST)

# Error estandar
ee_masculino <- sqrt(mean(residuos^2, na.rm = TRUE))

# Prueba de normalidad sobre los residuales
normalidad_masculino <- lillie.test(residuos)$p.value

# Prueba de homocedasticidad sobre los residuales
homocedasticidad_masculino <- bptest(lm(residuos ~ LRT_A + Edad, data = masculino2))$p.value

modelos_tab <- rbind(modelos_tab, 
                     data.frame(n = nrow(masculino),
                                R2 = r2_masculino,
                                EE = ee_masculino,
                                Normalidad = normalidad_masculino,
                                Homocedasticidad = homocedasticidad_masculino))

nombres <- c("Femenino", "Masculino")
modelos_tab <- cbind(nombres, modelos_tab)

modelos_tab |> gt()
```


## Cuadro Validación de las ecuaciones para estimar la talla en el grupo de validación

### Opción 1: Modelo normal LRT_A

Se muestra un resumen de los resultados del mejor modelo (normal con LRT_A) sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())

# Para mujeres
# Ajustar el modelo en el conjunto de entrenamiento
modelo <- lm(Talla ~ LRT_A + Edad, data = femenino)

# Hacer predicciones en el conjunto de validación (test)
predicciones <- predict(modelo, newdata = femenino_test)

# Calcular el R2 en test
SSE <- sum((femenino_test$Talla - predicciones)^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test$Talla - mean(femenino_test$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)


MSE_test <- mean((femenino_test$Talla - predicciones)^2)

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test),
                                    R2 = R2_test,
                                    Error_Puro = sqrt(MSE_test)))



# Para hombres 
# Ajustar el modelo en el conjunto de entrenamiento
modelo <- lm(Talla ~ LRT_A + Edad, data = masculino)

# Hacer predicciones en el conjunto de validación (test)
predicciones <- predict(modelo, newdata = masculino_test)

# Calcular el R2 en test
SSE <- sum((masculino_test$Talla - predicciones)^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test$Talla - mean(masculino_test$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)


MSE_test <- mean((masculino_test$Talla - predicciones)^2)

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = sqrt(MSE_test)))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```

### Opción 2: Modelo normal LRT_CM

Se muestra un resumen de los resultados del SEGUNDO mejor modelo (normal con LRT_CM) sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())

# Para mujeres
# Ajustar el modelo en el conjunto de entrenamiento
modelo <- lm(Talla ~ LRT_CM + Edad, data = femenino)

# Hacer predicciones en el conjunto de validación (test)
predicciones <- predict(modelo, newdata = femenino_test)

# Calcular el R2 en test
SSE <- sum((femenino_test$Talla - predicciones)^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test$Talla - mean(femenino_test$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)


MSE_test <- mean((femenino_test$Talla - predicciones)^2)

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test),
                                    R2 = R2_test,
                                    Error_Puro = sqrt(MSE_test)))



# Para hombres 
# Ajustar el modelo en el conjunto de entrenamiento
modelo <- lm(Talla ~ LRT_CM + Edad, data = masculino)

# Hacer predicciones en el conjunto de validación (test)
predicciones <- predict(modelo, newdata = masculino_test)

# Calcular el R2 en test
SSE <- sum((masculino_test$Talla - predicciones)^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test$Talla - mean(masculino_test$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)


MSE_test <- mean((masculino_test$Talla - predicciones)^2)

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = sqrt(MSE_test)))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```

### Opción 3: Fórmulas de Benjumea LRT_A

Se muestra un resumen de los resultados utilizando las fórmulas de Benjumea con LRT_A sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())
# Femenino
test2 <- estimaciones[-indices, ] 
femenino_test2 <- test2[test2$Sexo == "Femenino",]

# Residuales
residuos <- femenino_test2$Talla - femenino_test2$Benjumea_LRT_A

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test2$Talla - mean(femenino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))


modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test2),
                                    R2 = R2_test,
                                    Error_Puro = EP))



# Masculino
masculino_test2 <- test2[test2$Sexo == "Masculino",]

# Residuales
residuos <- masculino_test2$Talla - masculino_test2$Benjumea_LRT_A

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test2$Talla - mean(masculino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = EP))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```

### Opción 4: Fórmulas de Benjumea LRT_CM

Se muestra un resumen de los resultados utilizando las fórmulas de Benjumea con LRT_CM sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())
# Femenino

# Residuales
residuos <- femenino_test2$Talla - femenino_test2$Benjumea_LRT_CM

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test2$Talla - mean(femenino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))


modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test2),
                                    R2 = R2_test,
                                    Error_Puro = EP))



# Masculino

# Residuales
residuos <- masculino_test2$Talla - masculino_test2$Benjumea_LRT_CM

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test2$Talla - mean(masculino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = EP))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```

### Opción 5: Fórmulas de Arango y Zamora LRM_R

Se muestra un resumen de los resultados utilizando las fórmulas de Arango y Zamora con LRM_R (pierna estirada) sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())
# Femenino

# Residuales
residuos <- femenino_test2$Talla - femenino_test2$Arango_LRM_R

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test2$Talla - mean(femenino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))


modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test2),
                                    R2 = R2_test,
                                    Error_Puro = EP))



# Masculino

# Residuales
residuos <- masculino_test2$Talla - masculino_test2$Arango_LRM_R

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test2$Talla - mean(masculino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = EP))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```

### Opción 6: Fórmulas de Arango y Zamora LRM_90

Se muestra un resumen de los resultados utilizando las fórmulas de Arango y Zamora con LRM_90 sobre el conjunto de validación, por lo que se encuentra $n$ el  tamaño de muestra del conjunto de validación para cada subgrupo (femenino o masculino), el *r-*cuadrado (R2) y el error puro (Error_Puro).

```{r}
modelos_tab_val <- data.frame(n = numeric(),
                              R2 = numeric(),
                              Error_Puro = numeric())
# Femenino

# Residuales
residuos <- femenino_test2$Talla - femenino_test2$Arango_LRM_90

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((femenino_test2$Talla - mean(femenino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))


modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(femenino_test2),
                                    R2 = R2_test,
                                    Error_Puro = EP))



# Masculino

# Residuales
residuos <- masculino_test2$Talla - masculino_test2$Arango_LRM_90

# R cuadrado
SSE <- sum(residuos^2)  # Suma de errores cuadráticos
SST <- sum((masculino_test2$Talla - mean(masculino_test2$Talla))^2)  # Suma total de cuadrados
R2_test <- 1 - (SSE / SST)

# Error puro
EP <- sqrt(mean(residuos^2))

modelos_tab_val <- rbind(modelos_tab_val,
                         data.frame(n = nrow(masculino_test),
                                    R2 = R2_test,
                                    Error_Puro = EP))

nombres <- c("Femenino", "Masculino")
modelos_tab_val <- cbind(nombres, modelos_tab_val)

modelos_tab_val |> gt()
```